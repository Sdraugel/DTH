package advancedPricingUpload;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.math.RoundingMode;
import java.sql.*;
import java.text.DecimalFormat;
import javax.swing.JProgressBar;
import javax.swing.JTextArea;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.DataFormatter;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;

/**
 * Class used for formatting and uploading excel files to an Oracle Database
 * 
 * @author n556488  - Steven Draugel
 */
public class Upload {

	private String user; //db user
	private String pass; //db password
	private String SID; //db SID
	private String port; //db port
	private String DB_URL; //URL where the db is located
	private String DB_Conn; //connection variable used in building the db connection
	private String NNum; //the current user's N number
	private String currentDate; //today's date
	private String lastUser; //the last user to upload data to the specific table accessed
	private Integer lastWrite; //the last date, in YYYYMMDD format, data was uploaded to the db
	private File file; //the file being uploaded to the db
	private JTextArea log; //the gui logging area
	private JProgressBar progressBar; //a component that visually displays the progress of the rows being uploaded.
	private String sql; //the SQL query to be executed
	private Connection conn; //a connection (session) with a specific database. SQL statements are executed and results are returned within the context of a connection. 
	private Statement stmt; //the object used for executing a static SQL statement and returning the results it produces.
	private ResultSet rs; //a table of data representing a database result set, which is usually generated by executing a statement that queries the database. 
	
	
	/**
	 * Constructor
	 * 
	 * @param excelFile - the file being uploaded
	 * @param guilog - the logging space in the UI
	 * @param debug - boolean value that controls logging in the UI
	 */
	public Upload(File excelFile, JTextArea guilog, JProgressBar progress) {
		this.file = excelFile;
		this.log = guilog;
		this.progressBar = progress;
		this.progressBar.setValue(0);
		this.user = "";
		this.pass = "";
		this.SID = "";
		this.port = "";
		this.DB_URL = "m";	
		this.DB_Conn = "jdbc:oracle:thin:" + "@" + this.DB_URL + ":" + this.port + ":" + this.SID;
		this.NNum = getNNumber();
		this.currentDate = formatDate();
		this.progressBar.setValue(0);
		this.progressBar.update(progressBar.getGraphics());
		submitFile();
	}
	
	/**
	 * Sets up the database connection. Acts as the main method that kicks of the upload chain of events
	 * 
	 * @return
	 */
	private void submitFile(){

		try {
			this.conn = DriverManager.getConnection(this.DB_Conn, this.user, this.pass);
			this.stmt = conn.createStatement();
			
			selectUploadMethod();
			
			if (rs != null) {
				this.rs.close();
				this.stmt.close();
				this.conn.close();
				return;
			}
			
		} catch (SQLException se) { //handles errors for JDBC
			se.printStackTrace();
		} catch (Exception e) { //handles errors for Class.forName
			e.printStackTrace();
		} finally { //finally block used to close resources
			try {
				if (stmt!=null)
					stmt.close();
		   } catch (SQLException se2) {
		   	 }
		   try {
			   if (conn!=null)
				   conn.close();
		   } catch (SQLException se) {
			   se.printStackTrace();
		   }
	   }
		return;
	}
	
	/**
	 * Selects the upload method based on the name of the file being uploaded
	 * 
	 * @throws IOException
	 */
	private void selectUploadMethod() throws IOException {
		String dept = this.file.toString();
		
		if (dept.contains("Reduce Reimbursement")) {
			uploadRMBRSMNT(this.file);
		}
		if (dept.contains("PL BOL Level")) {
			uploadLogisticsCost(this.file);
		}
		if (dept.contains("G Code")) {
			uploadNIS(this.file);
		}
		if (dept.contains("Pros file for Commission and MCSN Dealers")) {
			uploadMSCNDealers(this.file);
		}
		if (dept.contains("Sales Hierarchy with Names and Titles")) {
			uploadSalesOrg(this.file);
		}
		if (dept.contains("Segment and Contracts")) {
			uploadSegmentsContracts(this.file);
		}
		if (dept.contains("Std Cost for PROs")) {
			uploadStandardCost(this.file);
		}
		if (dept.contains("Target Min Max")) {
			uploadMinMax(this.file);	
		}
		if (dept.contains("FVE")) {
			uploadFVE(this.file);
		}
		if (dept.contains("Margin and Weights")) {
			uploadMarginAndWeights(this.file);
		}
		else {
			this.log.append("Unknown file selected" + "\n" + "\n");
		}
		this.log.append("Upload complete" + "\n" + "\n");
		return;
		
	}

	/**
	 * Pulls the data out of the Reduce Reimbursement.xlsx file and uploads it to the DTH_APS_REIMBRSMNT table
	 * 
	 * @param file - the file the data is being extracted from
	 * @throws IOException
	 */
	private void uploadRMBRSMNT(File file) throws IOException {
		
        Sheet firstSheet = getSheet(file, 0); //the excel sheet being accessed		
		firstSheet.removeMergedRegion(1); //unmerges all merged regions of a specific row
		firstSheet = cleanDoc(firstSheet, 6); //removes the unwanted rows from the top of the excel doc
		int number = 1; //row number being uploaded, for debugging purposes
        int[] indexes = {4,6}; //the columns containing the wanted data
        int args = indexes.length; //total number of fields
		Object[] output = new Object[args - 1]; //object array that will store all the data being uploaded
		String[] fields = {"CUSTOMER_NBR", "REDUCTION"}; //the field names being uploaded
		String table_name = "DTH_APS_REIMBRSMNT"; //the table the data will be uploaded to
		this.lastUser = getLastUser(table_name); //returns the last user to upload data
		this.lastWrite = getLastWrite(table_name); //returns the last date data was uploaded		
		deleteData(table_name); //deletes all data contained in the table prior to uploading new data	
		log.append("Uploading " + file + " to " + table_name + "\n");
		
		//parses the excel doc and uploads the selected fields to the db
        for (int rIndex = 0; rIndex <= firstSheet.getLastRowNum(); rIndex++) {
        	
        	Row row = firstSheet.getRow(rIndex); //current row       	
        	int cols = row.getPhysicalNumberOfCells(); //number of columns in the current row
        	
        	//empties the output array each time a row is uploaded
        	if (row != null) {
        		for (int i = 0; i < args - 1; i++) {
        			output[i] = null;
        		}

        		output = getData(row, cols, indexes); //parses the excel doc and retrieves the data
        		updateProgress(number, firstSheet.getLastRowNum()); //updates the progress bar graphic
        		String[] tempArray = Arrays.asList(output).toArray(new String[output.length]); //now that the data was retrieved into the output array, it get's turned into an array of strings
    			try {
    				tempArray[0] = tempArray[0].toString();
    			}
    			catch (NullPointerException e){
    				tempArray[0] = "null"; //if the current array positon is null (empty), sets it to a null string
    			}

    			try {
    				String temp = tempArray[1].toString().replace("$", "").replace("   ", "").replace("(", "").replace(")", ""); //removes all the unwanted char from the string
    				tempArray[1] = temp;
    			}
    			catch (NullPointerException e) {
    				tempArray[1] = "null"; //if the current array positon is null (empty), sets it to a null string
    			}
        		
        		if (tempArray[0].equals("null")) { //position 0 is the primary key and thus cannot be null
        			this.log.append("-----ERROR-----");
        			this.log.append("EMPTY CUSTOMER_NBR FOUND ON ROW " + number + ". PLEASE INSURE ALL CUSTOMER_NBRS ARE NOT EMPTY OR DELETE THE ROW.");
        			return;
        		}
        		executeQuery(fields, tempArray, table_name);        	
        		number++;
        	}
        }
        return;        
	}

	/**
	 * Pulls the data out of the Std Cost for PROs.xlsx file and uploads it to the DTH_APS_REIMBRSMNT table
	 *
	 * @param file - the file the data is being extracted from
	 * @throws IOException
	 */
	private void uploadStandardCost(File file) throws IOException {
		Sheet firstSheet = getSheet(file, 0);      
		firstSheet = cleanDoc(firstSheet, 2);
		int number = 1; //row number for debugging  
        int[] indexes = {0,1};
        int args = indexes.length;
		Object[] output = new Object[args - 1];
		String[] fields = {"MSPN", "STD_COST"};
		String table_name = "DTH_APS_STD_COST";
		//int[] intIndexes = {};
		this.lastUser = getLastUser(table_name);
		this.lastWrite = getLastWrite(table_name);		
		deleteData(table_name);		
		log.append("Uploading " + file + " to " + table_name + "\n");
			
		//parses the excel doc and uploads the selected fields to the db
        for (int rIndex = 0; rIndex <= firstSheet.getLastRowNum(); rIndex++) {
        	Row row = firstSheet.getRow(rIndex);        	
        	int cols = row.getPhysicalNumberOfCells();
        	if (row != null) {
        		for (int i = 0; i < args - 1; i++) {
        			output[i] = null;
        		}

        		output = getData(row, cols, indexes); //parse doc and retrieve data
        		updateProgress(number, firstSheet.getLastRowNum());
        		String[] tempArray = Arrays.asList(output).toArray(new String[output.length]);
    			try {
    				tempArray[0] = tempArray[0].toString();
    			}
    			catch (NullPointerException e){
    				tempArray[0] = "null";
    			}

    			try {   				
    				tempArray[1] = tempArray[1].toString().replace("$", "").replace("   ", "");
    			}
    			catch (NullPointerException e) {
    				tempArray[1] = null;
    			}
        		
        		if (tempArray[0].equals("null")) {
        			this.log.append("-----ERROR-----");
        			this.log.append("EMPTY MSPN FOUND ON ROW " + number + ". PLEASE INSURE ALL MSPNS ARE NOT EMPTY OR DELETE THE ROW.");
        		}
        		executeQuery(fields, tempArray, table_name);       		
        		number++;
        	}
        }
        return;
	}

	/**
	 * Pulls the data out of the Segments and Contracts.xlsx file and uploads it to the DTH_APS_REIMBRSMNT table
	 * 
	 * @param file - the file the data is being extracted from
	 * @throws IOException
	 */
	private void uploadSegmentsContracts(File file) throws IOException {		
		Sheet firstSheet = getSheet(file, 0);        
		firstSheet = cleanDoc(firstSheet, 4);
		int number = 1; //row number for debugging  
        int[] indexes = {0,3,2};
        int args = indexes.length;
        Object[] output = new Object[args - 1];
		String[] fields = {"CUSTOMER_NBR", "SEGMENT", "CONTRACT"};
		String table_name = "DTH_APS_SEG_CONT";
		this.lastUser = getLastUser(table_name);
		this.lastWrite = getLastWrite(table_name);	
		deleteData(table_name);	
		log.append("Uploading " + file + " to " + table_name + "\n");
		
		//parses the excel doc and uploads the selected fields to the db
        for (int rIndex = 0; rIndex <= firstSheet.getLastRowNum(); rIndex++) {
        	Row row = firstSheet.getRow(rIndex);        	
        	int cols = row.getPhysicalNumberOfCells();
        	if (row != null) {
        		for (int i = 0; i < args - 1; i++) {
        			output[i] = null;
        		}

        		output = getData(row, cols, indexes); //parse doc and retrieve data
        		updateProgress(number, firstSheet.getLastRowNum());
        		String[] tempArray = Arrays.asList(output).toArray(new String[output.length]);
        		
        		for (int j = 0; j < args - 1; j++){
        			try {
        				tempArray[j] = tempArray[j].toString();
        			}
        			catch (NullPointerException e){
        				tempArray[j] = "null";
        			}
        		}
        		
        		if (tempArray[0].equals("null")) {
        			this.log.append("-----ERROR-----");
        			this.log.append("EMPTY CUSTOMER_NBR FOUND ON ROW " + number + ". PLEASE INSURE ALL CUSTOMER_NBRS ARE NOT EMPTY OR DELETE THE ROW.");
        		}
        		
        		if (tempArray[2].equals("No")) {
        			tempArray[2] = "N";
        		}
        		
        		if (tempArray[2].equals("Yes")) {
        			tempArray[2] = "Y";
        		}
        		executeQuery(fields, tempArray, table_name);        		
        		number++;
        	}
        }
        return;
	}

	/**
	 * Pulls the data out of the Sales Hierarchy with Names and Titles.xlsx file and uploads it to the DTH_APS_REIMBRSMNT table
	 * 
	 * @param file - the file the data is being extracted from
	 * @throws IOException
	 */
	private void uploadSalesOrg(File file) throws IOException {
		Sheet firstSheet = getSheet(file, 0); //loads the excel doc into the input stream		
		firstSheet = cleanDoc(firstSheet, 1); //removes excess top rows		
		int number = 1; //row number for debugging  
        int[] indexes = {6,4,2,0};
        int args = indexes.length;
        Object[] output = new Object[args - 1];
		String[] fields = {"TECHNICAL_KEY", "VP", "DIRECTOR", "MANAGER", "ACCOUNT_REP"};
		String table_name = "DTH_APS_SALES_ORG";
		this.lastUser = getLastUser(table_name);
		this.lastWrite = getLastWrite(table_name);		
		deleteData(table_name);
		createSequence(table_name);	
		log.append("Uploading " + file + " to " + table_name + "\n");
		
		//parses the excel doc and uploads the selected fields to the db
        for (int rIndex = 0; rIndex <= firstSheet.getLastRowNum(); rIndex++) {
        	Row row = firstSheet.getRow(rIndex);        	
        	int cols = row.getPhysicalNumberOfCells();
        	if (row != null) {
        		for (int i = 0; i < args - 1; i++) {
        			output[i] = null;
        		}

        		output = getData(row, cols, indexes); //parse doc and retrieve data	
        		updateProgress(number, firstSheet.getLastRowNum());
        		String[] tempArray = Arrays.asList(output).toArray(new String[output.length]);
        		
        		for (int j = 0; j < args; j++){
        			try {
        				tempArray[j] = tempArray[j].toString().replace("'", "''");
        			}
        			catch (NullPointerException e){
        				tempArray[j] = "null";
        			}
        			
        			//Sets the ACCOUNT_REP field to all uppercase
        			tempArray[3] = tempArray[3].toUpperCase();
        		} 
                executeQuery(fields, tempArray, table_name);         		
        		number++;
        	}
        }
        return;
	}


	/**
	 * Pulls the data out of the Pros file for Commission and MCSN Dealers.xlsx file and uploads it to the DTH_APS_REIMBRSMNT table
	 * This methods works a little different for this upload. The top section compiles a list from the
	 * another sheet in the excel workbook so that it can be compared with values in
	 * the first sheet. This is used to determine if the CUSTOMER_NBR is an MSCN_DEALER.
	 *
	 * @param file - the file the data is being extracted from
	 * @throws IOException
	 */
	private void uploadMSCNDealers(File file) throws IOException {

		// ---------top section---------
		Sheet secondSheet = getSheet(file, 3);
		secondSheet = cleanDoc(secondSheet, 3);
		Object[] arr = new Object[secondSheet.getLastRowNum()];
		List<String> Temp_Array = new ArrayList<String>();
		int[] ind = {0};
		
		for (int rIndex2 = 0; rIndex2 < secondSheet.getLastRowNum(); rIndex2++) {
			Row row = secondSheet.getRow(rIndex2);
			int cols = row.getPhysicalNumberOfCells();
			arr = getData(row, cols, ind);
			Temp_Array.add(arr[0].toString());			
		}
		String[] MCSN_Dealers = new String[ Temp_Array.size() ];
		Temp_Array.toArray( MCSN_Dealers );
		// -------end top section-------
		
		Sheet firstSheet = getSheet(file, 0); //loads the excel doc into the input stream
		firstSheet = cleanDoc(firstSheet, 5); //removes excess top rows
		
		int number = 0; //row number for debugging  
        int[] indexes = {0,2,1};
        int args = indexes.length;
        Object[] output = new Object[args - 1];
		String[] fields = {"CUSTOMER_NBR", "COMMISSION_SCHED", "MCSN_DEALER"};
		String table_name = "DTH_APS_MCSN_DEALER";
		this.lastUser = getLastUser(table_name);
		this.lastWrite = getLastWrite(table_name);		
		deleteData(table_name);		
		log.append("Uploading " + file + " to " + table_name + "\n");
		
		//parses the excel doc and uploads the selected fields to the db
        for (int rIndex = 0; rIndex <= firstSheet.getLastRowNum(); rIndex++) {
        	Row row = firstSheet.getRow(rIndex);        	
        	int cols = row.getPhysicalNumberOfCells();
        	if (row != null) {
        		for (int i = 0; i < args - 1; i++) {
        			output[i] = null;
        		}

        		output = getData(row, cols, indexes); //parse doc and retrieve data
        		updateProgress(number, firstSheet.getLastRowNum());
        		String[] tempArray = Arrays.asList(output).toArray(new String[output.length]);
        		
        		for (int j = 0; j < args - 1; j++){
        			try {
        				tempArray[j] = tempArray[j].toString();
        			}
        			catch (NullPointerException e){
        				tempArray[j] = "null";
        			}
        		}
        		
        		if (tempArray[0].equals("null")) {
        			this.log.append("-----ERROR-----");
        			this.log.append("EMPTY CUSTOMER_NBR FOUND ON ROW " + number + ". PLEASE INSURE ALL CUSTOMER_NBRS ARE NOT EMPTY OR DELETE THE ROW.");
        		}
        		
        		// compares the CUSTOMER_NBR with the list of MCSN_Dealers to find matches
        		for (int k = 0; k < MCSN_Dealers.length; k++) {
        			if (tempArray[0] != null && MCSN_Dealers[k] != null) {
        				if (tempArray[0].equals(MCSN_Dealers[k])) {
	        				tempArray[2] = "Y";
	        			}
        			}
        		}
        		
        		if (tempArray[2].equals("Y") != true) {
        			tempArray[2] = "N";
        		}
        		executeQuery(fields, tempArray, table_name);         		
        		number++;
        	}
        }
        return;
	}

	/**
	 * Pulls the data out of the G Code.xlsx file and uploads it to the DTH_APS_REIMBRSMNT table
	 * 
	 * @param file - the file the data is being extracted from
	 * @throws IOException
	 */
	private void uploadNIS(File file) throws IOException {
		Sheet firstSheet = getSheet(file, 4); //loads the excel doc into the input stream		
		firstSheet = cleanDoc(firstSheet, 2); //removes excess top rows		
		Integer number = 1; //row number for debugging  
        int[] indexes = {0,2,1};
        int args = indexes.length;
        Object[] output = new Object[args - 1];
		String[] fields = {"MSPN", "ACCRUAL_CODE", "NIS", "TECHNICAL_KEY"};
		String table_name = "DTH_APS_NIS";
		this.lastUser = getLastUser(table_name);
		this.lastWrite = getLastWrite(table_name);		
		createSequence(table_name);
		deleteData(table_name);		
		log.append("Uploading " + file + " to " + table_name + "\n");
		
		//parses the excel doc and uploads the selected fields to the db
        for (int rIndex = 0; rIndex <= firstSheet.getLastRowNum(); rIndex++) {
        	Row row = firstSheet.getRow(rIndex);        	
        	int cols = row.getPhysicalNumberOfCells();
        	if (row != null) {
        		for (int i = 0; i < args - 1; i++) {
        			output[i] = null;
        		}

        		output = getData(row, cols, indexes); //parse doc and retrieve data
        		updateProgress(number, firstSheet.getLastRowNum());
        		
        		String[] tempArray = Arrays.asList(output).toArray(new String[output.length]);
        		
        		for (int j = 0; j < args - 1; j++){
        			try {
        				tempArray[j] = tempArray[j].toString();
        			}
        			catch (NullPointerException e){
        				tempArray[j] = "null";
        			}
        			catch (ClassCastException e) {
        				tempArray[j] = (String) tempArray[j].toString();
        			}
        		}
        		
        		if (tempArray[0] == "null") {
        			this.log.append("-----ERROR-----");
        			this.log.append("EMPTY MSPN FOUND ON ROW " + number + ". PLEASE INSURE ALL MSPNS ARE NOT EMPTY OR DELETE THE ROW.");
        		}
        		executeQuery(fields, tempArray, table_name);       		
        		number++;
        	}
        }
        return;
	}

	/**
	 * Pulls the data out of the PL BOL Level - Cust Ships with pivot.xlsx file and uploads it to the DTH_APS_REIMBRSMNT table
	 *
	 * @param file - the file the data is being extracted from
	 * @throws IOException
	 */
	private void uploadLogisticsCost(File file) throws IOException {
		Sheet firstSheet = getSheet(file, 0); //loads the excel doc into the input stream		
		firstSheet = cleanDoc(firstSheet, 3); //removes excess top rows
		int number = 0; //row number for debugging  
        int[] indexes = {0,4};
        int args = indexes.length;
        Object[] output = new Object[args - 1];
		String[] fields = {"CUSTOMER_NBR", "LOG_COST"};
		String table_name = "DTH_APS_LOG_COST";
		this.lastUser = getLastUser(table_name);
		this.lastWrite = getLastWrite(table_name);		
		deleteData(table_name);		
		log.append("Uploading " + file + " to " + table_name + "\n");
		
		//parses the excel doc and uploads the selected fields to the db
        for (int rIndex = 0; rIndex <= firstSheet.getLastRowNum(); rIndex++) {
        	Row row = firstSheet.getRow(rIndex);        	
        	int cols = row.getPhysicalNumberOfCells();
        	if (row != null) {
        		for (int i = 0; i < args - 1; i++) {
        			output[i] = null;
        		}

        		output = getData(row, cols, indexes); //parse doc and retrieve data
        		updateProgress(number, firstSheet.getLastRowNum());
        		String[] tempArray = Arrays.asList(output).toArray(new String[output.length]);
        		String temp = "0.0";
    			try {
    				tempArray[0] = tempArray[0].toString();
    			}
    			catch (NullPointerException e){
    				tempArray[0] = "null";
    				this.log.append("-----ERROR-----");
        			this.log.append("EMPTY CUSTOMER_NBR FOUND ON ROW " + number + ". PLEASE INSURE ALL CUSTOMER_NBRS ARE NOT EMPTY OR DELETE THE ROW.");
        			return;
    			}
    			
    			try {
    				if (tempArray[1].toString().contains("-")) {
    					temp = "0.0";
    				}
    				else {
    					temp = tempArray[1].toString().replace("$   ", "").replace(",", "").trim();
    				}			
    				tempArray[1] = temp;
    			}
    			catch (NullPointerException e) {
    				temp = "0.0";
    				tempArray[1] = temp;
    			}
        		
        		if (tempArray[0] == "null") {
        			this.log.append("-----ERROR-----");
        			this.log.append("EMPTY CUSTOMER_NBR FOUND ON ROW " + number + ". PLEASE INSURE ALL CUSTOMER_NBRS ARE NOT EMPTY OR DELETE THE ROW.");
        			return;
        		}
        		executeQuery(fields, tempArray, table_name);         		
        		number++;
        	}
        }
        return;
	}
	
	/**
	 * Pulls the data out of the PROs Target Min Max.xlsx file and uploads it to the DTH_APS_REIMBRSMNT table
	 * 
	 * @param file - the file the data is being extracted from
	 * @throws IOException
	 */
	private void uploadMinMax(File file) throws IOException {
		Sheet firstSheet = getSheet(file, 0);		
		firstSheet = cleanDoc(firstSheet, 2);
		int number = 1; //row number for debugging  
        int[] indexes = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27};
        int args = indexes.length;
		Object[] output = new Object[args - 1];
		String[] fields = {"MSPN", 
				"B1_MAX", 
				"B1_TARGET", 
				"B1_MIN", 
				"B2_MAX",
				"B2_TARGET",
				"B2_MIN",
				"B3_MAX",
				"B3_TARGET",
				"B3_MIN",
				"B4_MAX",
				"B4_TARGET",
				"B4_MIN",
				"B5_MAX",
				"B5_TARGET",
				"B5_MIN",
				"B6_MAX",
				"B6_TARGET",
				"B6_MIN",
				"B7_MAX",
				"B7_TARGET",
				"B7_MIN",
				"B8_MAX",
				"B8_TARGET",
				"B8_MIN",
				"B9_MAX",
				"B9_TARGET",
				"B9_MIN"};
		String table_name = "DTH_APS_MIN_MAX";
		this.lastUser = getLastUser(table_name);
		this.lastWrite = getLastWrite(table_name);		
		deleteData(table_name);	
		log.append("Uploading " + file + " to " + table_name + "\n");
		
		//parses the excel doc and uploads the selected fields to the db
        for (int rIndex = 0; rIndex <= firstSheet.getLastRowNum(); rIndex++) {
        	
        	Row row = firstSheet.getRow(rIndex);        	
        	int cols = row.getPhysicalNumberOfCells();
        	
        	if (row != null) {
        		for (int i = 0; i < args - 1; i++) {
        			output[i] = null;
        		}

        		output = getData(row, cols, indexes); //parse doc and retrieve data
        		updateProgress(number, firstSheet.getLastRowNum());
        		String[] tempArray = Arrays.asList(output).toArray(new String[output.length]);
    			try {
    				tempArray[0] = tempArray[0].toString();
    			}
    			catch (NullPointerException e){
    				tempArray[0] = "null";
    			}

    			try {
    				for (int i = 1; i < 28; i++) {
    					String temp = tempArray[1].toString().replace("$", "").replace("   ", "").replace("(", "").replace(")", "").replace(",", ""); 
        				if (temp == "PQL") {
        					temp = " ";
        				}
    					tempArray[i] = temp;
    				}	
    			}
    			catch (NullPointerException e) {
    				System.out.println("Found a null");
    			}
        		
        		if (tempArray[0].equals("null")) {
        			this.log.append("-----ERROR-----");
        			this.log.append("EMPTY MSPN FOUND ON ROW " + number + ". PLEASE INSURE ALL CUSTOMER_NBRS ARE NOT EMPTY OR DELETE THE ROW.");
        			return;
        		}    		
        		executeQuery(fields, tempArray, table_name);      
        		number++;  
        	}
        }
		return;
	}
	/**
	 * Pulls the data out of the PROs Bracket and FVE by Ship to.xlsx file and uploads it to the DTH_APS_REIMBRSMNT table
	 * 
	 * @param file - the file the data is being extracted from
	 * @throws IOException
	 */
	private void uploadFVE (File file) throws IOException {
		Sheet firstSheet = getSheet(file, 0);		
		firstSheet = cleanDoc(firstSheet, 1);
		int number = 1; //row number for debugging  
        int[] indexes = {0,1,2,3,4,5,6,7,8,9};
        int args = indexes.length;
		Object[] output = new Object[args - 1];
		String[] fields = {"HIGHEST_LVL_CUSTOMER",
							"HIGHEST_LVL_CUSTOMER_DESC",
							"HOME_OFFICE_CUSTOMER",
							"HOME_OFFICE_CUSTOMER_DESC",
							"BILL_TO_CUSTOMER",
							"BILL_TO_CUSTOMER_DESC",
							"SHIP_TO_CUSTOMER",
							"SHIP_TO_CUSTOMER_DESC",
							"BRACKET",
							"FVE"};
		String table_name = "DTH_APS_FVE_FILE";
		this.lastUser = getLastUser(table_name);
		this.lastWrite = getLastWrite(table_name);	
		deleteData(table_name);		
		log.append("Uploading " + file + " to " + table_name + "\n");
		
		//parses the excel doc and uploads the selected fields to the db
        for (int rIndex = 0; rIndex <= firstSheet.getLastRowNum(); rIndex++) {
        	
        	Row row = firstSheet.getRow(rIndex);        	
        	int cols = row.getPhysicalNumberOfCells();
        	
        	if (row != null) {
        		for (int i = 0; i < args - 1; i++) {
        			output[i] = "null";
        		}

        		output = getData(row, cols, indexes); //parse doc and retrieve data
        		updateProgress(number, firstSheet.getLastRowNum());
        		String[] tempArray = Arrays.asList(output).toArray(new String[output.length]);

    			try {
    				for (int i = 0; i < tempArray.length; i++) {
    					String temp = tempArray[i].toString().replace("$", "").replace("   ", "").replace("(", "").replace(")", "").replaceAll("'", ""); 
    					tempArray[i] = temp;
    				}    				
    			}
    			catch (NullPointerException e) {
    				if (tempArray[0].equals("null")) {
    					tempArray[0] = "null";
    				}
    			}
        		
        		if (tempArray[0].equals("null")) {
        			this.log.append("-----ERROR-----");
        			this.log.append("EMPTY CUSTOMER_NBR FOUND ON ROW " + number + ". PLEASE INSURE ALL CUSTOMER_NBRS ARE NOT EMPTY OR DELETE THE ROW.");
        			return;
        		}	
        		executeQuery(fields, tempArray, table_name);  
        		number++;  
        	}
        }		
		return;
	}
	
	/**
	 * Pulls the data out of the PROs Bracket and FVE by Ship to.xlsx file and uploads it to the DTH_APS_REIMBRSMNT table
	 * 
	 * @param file - the file the data is being extracted from
	 * @throws IOException
	 */
	private void uploadMarginAndWeights (File file) throws IOException {
		Sheet firstSheet = getSheet(file, 0);		
		firstSheet = cleanDoc(firstSheet, 1);
		int number = 1; //row number for debugging  
        int[] indexes = {0,2};
        int args = indexes.length;
		Object[] output = new Object[args - 1];
		String[] fields = {"MSPN", "TREAD_WEIGHT", "TECHNICAL_KEY"};
		String table_name = "DTH_APS_WEIGHT";
		this.lastUser = getLastUser(table_name);
		this.lastWrite = getLastWrite(table_name);	
		deleteData(table_name);		
		log.append("Uploading " + file + " to " + table_name + "\n");
		
		//parses the excel doc and uploads the selected fields to the db
        for (int rIndex = 0; rIndex <= firstSheet.getLastRowNum(); rIndex++) {
        	
        	Row row = firstSheet.getRow(rIndex);        	
        	int cols = row.getPhysicalNumberOfCells();
        	
        	if (row != null) {
        		for (int i = 0; i < args - 1; i++) {
        			output[i] = "null";
        		}

        		output = getData(row, cols, indexes); //parse doc and retrieve data
        		updateProgress(number, firstSheet.getLastRowNum());
        		String[] tempArray = Arrays.asList(output).toArray(new String[output.length]);

    			try {
    				tempArray[0] = tempArray[0].toString();    				
    			}
    			catch (NullPointerException e) {
    				tempArray[0] = "null";
    			}
    			
    			try {
    				tempArray[1] = tempArray[1].toString();    				
    			}
    			catch (NullPointerException e) {
    				tempArray[1] = "null";
    			}
        		
        		if (tempArray[0].equals("null")) {
        			this.log.append("-----ERROR-----");
        			this.log.append("EMPTY MSPN FOUND ON ROW " + number + ". PLEASE INSURE ALL CUSTOMER_NBRS ARE NOT EMPTY OR DELETE THE ROW.");
        			return;
        		}	
        		executeQuery(fields, tempArray, table_name);  
        		number++;  
        	}
        }		
		return;
	}
		
//--------------------Utility Methods-------------------------------------------------------//
	/**
	 * Deletes all rows from the passed in table_name
	 * 
	 * @param table_name
	 */
	private void deleteData(String table_name) {
		sql = "DELETE FROM " + table_name;
		String commit = "commit";
		try {
			this.rs = stmt.executeQuery(sql);
			this.rs = stmt.executeQuery(commit);
		} catch (SQLException e) {
			e.printStackTrace(); //any errors are printed via console logging
		}
		return;
	}
	
	/**
	 * This method takes in an excel sheet object and a starting row and removes all rows above
	 * the starting row.
	 * 
	 * @param firstSheet - the sheet being accessed
	 * @param rowIndex - the row that the wanted data starts at
	 * @return firstSheet - the sheet after lines are removed
	 */
	private Sheet cleanDoc(Sheet firstSheet, int rowIndex) {
        int lastRowNum = firstSheet.getLastRowNum(); 
        while (rowIndex > 0) {
		    if(rowIndex >=0 && rowIndex < lastRowNum){
		    	firstSheet.shiftRows(rowIndex,lastRowNum, -1);
		    }
		    if(rowIndex == lastRowNum){
		        XSSFRow removingRow = (XSSFRow) firstSheet.getRow(rowIndex);
		        if(removingRow != null){
		        	firstSheet.removeRow(removingRow);
		        }
		    }
		    rowIndex--;
        }        
        return firstSheet;
		
	}
	
	/**
	 * pulls out the data from an excel cell, formats it to a String, and returns it
	 * 
	 * @param cell - the excel cell containing the data
	 * @return x - the String formatted cell value
	 */
	private String poiGetCellValue(Cell cell){
	    DataFormatter format = new DataFormatter();
	    String x = format.formatCellValue(cell);
	    return x;
	}
	
	/**
	 * opens an excel file and loads the desired sheet
	 * 
	 * @param file - the selected excel file
	 * @param index - the index the sheet is located
	 * @return firstSheet
	 * @throws IOException
	 */
	private Sheet getSheet(File file, int index) throws IOException {
		FileInputStream inputStream = new FileInputStream(file);
        XSSFWorkbook workbook = new XSSFWorkbook(inputStream);
        Sheet firstSheet = workbook.getSheetAt(index);
        workbook.close();
		return firstSheet;
	}
	
	/**
	 * Gets the data from cells in a given sheet. Specifically pulls out data in String format
	 * when a formula is present in the cell
	 * 
	 * @param row - the current row
	 * @param cols - the current column
	 * @param indexes - the column positions containing the required data
	 * @return arr - object array containing all data for the specified row x cols
	 */
	@SuppressWarnings("static-access")
	private Object[] getData(Row row, int cols, int[] indexes) {	
		DataFormatter df = new DataFormatter();
		Cell cell = null;
		Object[] arr = new Object[indexes.length];
		
		for (int colIndex = 0; colIndex < cols + 2; colIndex++) {
			for (int i = 0; i < indexes.length; i++) {
				if (colIndex == indexes[i]) {
					cell = row.getCell(colIndex);
					df.formatCellValue(cell);
					if (cell != null && cell.getCellType() == cell.CELL_TYPE_FORMULA) {
						switch(cell.getCachedFormulaResultType()) {
							case Cell.CELL_TYPE_NUMERIC:
								arr[i] = cell.getNumericCellValue();
								arr[i] = String.valueOf(arr[i]);
								break;
							case Cell.CELL_TYPE_STRING:
								arr[i] = cell.getStringCellValue();
								break;
						}					
					}
					else {
						arr[i] = poiGetCellValue(cell);
					}
				}
			}
		}	
		return arr;
	}
	
	/**
	 * Builds an executes an SQL query
	 * 
	 * @param fields - the db fields the data is being uploaded to
	 * @param tempArray - the array containing the data to be uploaded
	 * @param table_name - the table_name the data is to be uploaded to
	 */
	private void executeQuery(String[] fields, String[] tempArray, String table_name) {
		String seq = table_name + "_SEQ.NEXTVAL";
		String sql = "INSERT INTO " + table_name + "(" + 
					 "T_LAST_USER_ID, T_CREATOR_ID, T_CREATION_DATE, T_LAST_WRITE, ";

		for (int i = 0; i < fields.length; i++) {
			if (i < fields.length -1) {
				sql += fields[i] + ", ";
			}
			else {
				sql += fields[i] + ")";
			}
		}
		
		sql += " VALUES ('" + this.lastUser + 
				"', '" + this.NNum + "', '" + 
				this.currentDate + "', '" + this.lastWrite  + "', ";
		
		for (int j = 0; j < tempArray.length; j++) {
			if (j < tempArray.length - 1 && table_name.contains("DTH_APS_SALES_ORG") == false) {
				sql += "'" + tempArray[j] + "'" + ", ";	
			}
			
			if (j < tempArray.length - 1 && j != 0 && table_name.contains("DTH_APS_SALES_ORG") == true){
				sql += "'" + tempArray[j] + "'" + ", ";	
			}
			
			if (j == 0 && table_name.contains("DTH_APS_SALES_ORG") == true) {
				sql += seq + ", ";
				sql += "'" + tempArray[j] + "'" + ", ";
			}
			
			if (j > tempArray.length - 2 && table_name.contains("DTH_APS_NIS") == true) {
				sql += "'" + tempArray[j] + "'" + ", ";	
				sql += seq + ")";
			}
			
			if (j > tempArray.length - 2 && table_name.contains("DTH_APS_NIS") == false && table_name.contains("DTH_APS_WEIGHT") == false) {
				sql += "'" + tempArray[j] + "'" + ")";	
			}
			
			if (j > tempArray.length - 2 && table_name.contains("DTH_APS_WEIGHT") == true) {
				sql += "'" + tempArray[j] + "'" + ", ";	
				sql += seq + ")";
			}
		}
		
		this.log.append("\n" + sql + "\n");
		log.setText(log.getText());
		log.update(log.getGraphics());
		
        if (tempArray[0] != "null" && tempArray[0] != "") {
            try {
            	int success = stmt.executeUpdate(sql);
    			if (success > 0) {
    				this.log.append("\n" + "~~~~~Upload succeeded~~~~~" + "\n");		
    			}
    			else {
    				this.log.append("\n" + "~~~~~Upload failed~~~~~" + "\n");
    			}
    		} catch (SQLException e) {
    			e.printStackTrace();
    		}
        }      	
		return;
	}
	
	/**
	 * Gets the last user's N# that made an entry into the table
	 * 
	 * @param tableName - the name of the table being accessed
	 * @return output - the last user to make an entry
	 */
	private String getLastUser(String tableName) {
		
		//The select statement used in finding the last person to upload data
		String userQuery = "SELECT T_CREATOR_ID, T_CREATION_DATE FROM ";
		userQuery += tableName + " WHERE T_CREATION_DATE = ";
		userQuery += "(SELECT MAX(T_CREATION_DATE) FROM " + tableName +  ") ";
		userQuery += "GROUP BY T_CREATION_DATE, T_CREATOR_ID";
		
		String output = " ";
		ResultSet result = null;
		
		try {
			result = stmt.executeQuery(userQuery);
			while (result.next()) {
				if (result.toString().equals(null)) {
					output = " ";
				}
				else {
					output = result.getString("T_CREATOR_ID");
				}
			}
			result.close();
		} catch (SQLException e) {
			//System.out.println("");
		}
		
		if (output == null) {
			output = " ";
		}
		
		return output;
	}
	
	/**
	 * This method retrieves the last date that an entry to a table was made.
	 * Currently awaiting DB repairs to implement this method.
	 * 
	 * @return result - the last entry date
	 */
	private Integer getLastWrite(String tableName) {
		
		//The select statement used in finding the last person to upload data
				String userQuery = "SELECT T_CREATOR_ID, T_CREATION_DATE FROM ";
				userQuery += tableName + " WHERE T_CREATION_DATE = ";
				userQuery += "(SELECT MAX(T_CREATION_DATE) FROM " + tableName +  ") ";
				userQuery += "GROUP BY T_CREATION_DATE, T_CREATOR_ID";
				
				ResultSet result = null;
				Integer output = 0;
				String[] date = new String[10];
				
				try {
					result = stmt.executeQuery(userQuery);
					while (result.next()) {
						if (result.toString().equals(null)) {
							output = 0;
						}
						else {
							date = result.getString("T_CREATION_DATE").split(" ");
							date[0] = date[0].replace("-", "");
							//System.out.println(date[0]);							
							output = Integer.parseInt(date[0]);
						}
					}
					result.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
				
				return output;
	}
	
	/**
	 * Gets the current data
	 * 
	 * @return the current date formatted into a string
	 */
	private String formatDate() {
		Date date = new Date();
		String[] arr = date.toString().split(" ");
		return arr[2] + " " + arr[1] + " " + arr[5];
	}

	/**
	 * Updates the progress bar with the current upload progress
	 * 
	 * @param currentRecord - the record number being uploaded
	 * @param length - total number of records being uploaded
	 */
	private void updateProgress(double currentRecord, double length) {
		double value = (currentRecord / (length + 1)) * 100;
		DecimalFormat df = new DecimalFormat("#");
		df.setRoundingMode(RoundingMode.CEILING);	
		int wholeValue = Integer.valueOf(df.format(value));
		progressBar.setValue(wholeValue);
		progressBar.update(progressBar.getGraphics());
		return;
	}
	
	/**
	 * creates the db sequence object in order to maintain data integrity
	 * 
	 * @param table_name - the table name being uploaded to
	 */
	private void createSequence(String table_name) {
		String createSeq = "CREATE SEQUENCE " + table_name + "_SEQ " +
				"INCREMENT BY 1 " +
				"START WITH 1" +
				"MAXVALUE 999999999999999 " +
				"NOCACHE " +
				"CYCLE " +
				"ORDER ";
		try {
			stmt.executeQuery(createSeq);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return;
	}
	
	/**
	 * Gets the N Number of the person uploading the file
	 * 
	 * @return result - the N number
	 */
	private String getNNumber() {
		String result = this.file.toString();
		String[] arr = result.split("\\\\");
		result = arr[2];
		result.toUpperCase();
		return result;
	}
	//-------------------------------------------------------------------------------------//
}















 
